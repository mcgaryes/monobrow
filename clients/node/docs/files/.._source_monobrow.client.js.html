<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..&#x2F;source&#x2F;monobrow.client.js - monobrow-client</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="monobrow-client"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Client.html">Client</a></li>
            
                <li><a href="..&#x2F;classes/Logger.html">Logger</a></li>
            
                <li><a href="..&#x2F;classes/Manager.html">Manager</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ..&#x2F;source&#x2F;monobrow.client.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;&#x2F; ============================================================
&#x2F;&#x2F; === Client =================================================
&#x2F;&#x2F; ============================================================

&#x2F;**
 * Client for connecting to a Monobrow server.
 * @class Client
 * @constructor
 *&#x2F;
var Client = module.exports = function(options) {

    &#x2F;&#x2F; create a logger for the client
    var logger = this._logger = new Logger(options);

    &#x2F;&#x2F; initialize the client
    this.__initialize();

    &#x2F;&#x2F; extend our instance with the passed options
    _.extend(this, options);

};

Client.prototype = Object.create(Backbone.Events, {

    &#x2F;&#x2F; ============================================================
    &#x2F;&#x2F; === Public Properties ======================================
    &#x2F;&#x2F; ============================================================

    &#x2F;**
     * Public getter for the current state of the client.
     * @property state
     * @type String
     *&#x2F;
    state: {
        get: function() {
            return this._state;
        }
    },

    &#x2F;**
     * Public getter for the previous state of the client.
     * @property previousState
     * @type String
     *&#x2F;
    previousState: {
        get: function() {
            return this._previousState;
        }
    },

    &#x2F;**
     * The host the client will connect to
     * @property host
     * @type String
     * @default localhost
     *&#x2F;
    host: {
        value: &quot;localhost&quot;,
        writable: true
    },

    &#x2F;**
     * The port the socket will connect to
     * @property port
     * @type Integer
     * @default 8889
     *&#x2F;
    port: {
        value: 8889,
        writable: true
    },

    &#x2F;&#x2F; ============================================================
    &#x2F;&#x2F; === Public Methods =========================================
    &#x2F;&#x2F; ============================================================

    &#x2F;**
     * Connects the client to the remote socket server.
     * @method connect
     *&#x2F;
    connect: {
        value: function() {
            if (this._state !== Client.STATE_CONNECTED) {
                this._socket.connect(this.port, this.host);
            } else {
                this._logger.warn(&quot;Client is already connected to the server.&quot;);
            }
        }
    },

    &#x2F;**
     * Diconnects the client from the remote socket server.
     * @method disconnect
     *&#x2F;
    disconnect: {
        value: function() {
            if (this._state === Client.STATE_CONNECTED) {
                throw &quot;Disconnect not yet implemented.&quot;;
            }
        }
    },

    &#x2F;**
     * Emits a message to the server the client is connected to.
     * @method emit
     *&#x2F;
    emit: {
        value: function(message) {
            if (this._state === Client.STATE_CONNECTED) {
                try {
                    this._socket.write(message);
                } catch(e) {
                    this._logger.error(e.message);
                }
            } else {
                this._logger.warn(&quot;Client must be connected to emit a message.&quot;);
            }
        }
    },

    &#x2F;&#x2F; ============================================================
    &#x2F;&#x2F; === Public Methods =========================================
    &#x2F;&#x2F; ============================================================

    &#x2F;**
     *
     * @method __initialize
     * @private
     *&#x2F;
    __initialize: {
        value: function() {

            this._state = Client.STATE_INITIALIZED;

            &#x2F;&#x2F; create the socket server we&#x27;ll use to connect to the server with
            this._socket = net.Socket();

            &#x2F;&#x2F; assing a delegate for use with the listener callbacks
            var delegate = this;

            &#x2F;&#x2F; add listeners for the socket instance
            this._socket.on(&quot;error&quot;, function(e) {
                delegate.__handleSocketError(e);
            });

            this._socket.on(&quot;connect&quot;, function() {
                delegate.__handleSocketConnect();
            });

            this._socket.on(&quot;data&quot;, function(data) {
                delegate.__handleSocketData(data);
            });

            this._socket.on(&quot;close&quot;, function(hasError) {
                delegate.__handleSocketClose(hasError);
            });
            
        }
    },

    &#x2F;**
     * This method is just used for logging purposes. If an error occurs
     * the close method is called immediately after and we&#x27;ll handle
     * triggering the state change there, not here.
     * @method __handleSocketError
     * @param {Object} e Socket error object
     * @private
     *&#x2F;
    __handleSocketError: {
        value: function(e) {
            if (e.code === &quot;EADDRNOTAVAIL&quot;) {
                this._logger.error(&quot;Server not available at &quot; + this.host + &quot;:&quot; + this.port + &quot;.&quot;);
            } else if (e.code === &quot;ECONNREFUSED&quot;) {
                this._logger.error(&quot;The connection to &quot; + this.host + &quot;:&quot; + this.port + &quot; was refused.&quot;);
            }
        }
    },

    &#x2F;**
     *
     * @method __handleSocketConnect
     * @private
     *&#x2F;
    __handleSocketConnect: {
        value: function() {
            this._logger.log(&quot;Client connected to &quot; + this.host + &quot;:&quot; + this.port + &quot;.&quot;);
            this._previousState = this._state;
            this._state = Client.STATE_CONNECTED;
            this.trigger(Client.STATE_CHANGE, this._state, this._previousState);
        }
    },

    &#x2F;**
     *
     * @method __handleSocketData
     * @param {Buffer} data The raw data sent from the server
     * @private
     *&#x2F;
    __handleSocketData: {
        value: function(data) {
            this.trigger(Client.DATA, data);
        }
    },

    &#x2F;**
     *
     * @method __handleSocketClose
     * @param {Object} error Socket error object
     * @private
     *&#x2F;
    __handleSocketClose: {
        value: function(hasError) {
            this._previousState = this._state;
            if (hasError) {
                this._state = Client.STATE_ERROR;
                this.trigger(Client.STATE_CHANGE, this._state, this._previousState);
            } else {
                this._logger.log(&quot;Client disconnected from &quot; + this.host + &quot;:&quot; + this.port + &quot;.&quot;);
                this._state = Client.STATE_DISCONNECTED;
                this.trigger(Client.STATE_CHANGE, this._state, this._previousState);
            }
        }
    }

});

&#x2F;&#x2F; ============================================================
&#x2F;&#x2F; === Events =================================================
&#x2F;&#x2F; ============================================================

&#x2F;**
 * State change event fired on a state change of the client.
 * @property STATE_CHANGE
 * @type String
 * @static
 *&#x2F;
Client.STATE_CHANGE = &quot;stateChangeEvent&quot;;


&#x2F;**
 * The data event is fired when incoming data is recognized. The data
 * passed is the raw buffer. Call toString on the data to get the string
 * representation of the data.
 * @property DATA
 * @type String
 * @static
 *&#x2F;
Client.DATA = &quot;dataEvent&quot;;

&#x2F;&#x2F; ============================================================
&#x2F;&#x2F; === States =================================================
&#x2F;&#x2F; ============================================================

&#x2F;**
 * The client is connected to the remote socket server.
 * @property STATE_CONNECTED
 * @type String
 * @static
 *&#x2F;
Client.STATE_INITIALIZED = &quot;initialized&quot;;

&#x2F;**
 * The client is connected to the remote socket server.
 * @property STATE_CONNECTED
 * @type String
 * @static
 *&#x2F;
Client.STATE_CONNECTED = &quot;connected&quot;;

&#x2F;**
 * The client has diconnected from the remote socket server.
 * @property STATE_DISCONNECTED
 * @type String
 * @static
 *&#x2F;
Client.STATE_DISCONNECTED = &quot;disconnected&quot;;

&#x2F;**
 * The client has encountered an error connecting to the remote socket server.
 * @property STATE_ERROR
 * @type String
 * @static
 *&#x2F;
Client.STATE_ERROR = &quot;error&quot;;
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
